;buildInfoPackage: chisel3, version: 3.4.3, scalaVersion: 2.12.12, sbtVersion: 1.3.10
circuit UartSystem : 
  module UartRx : 
    input clock : Clock
    input reset : Reset
    output io : {out : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>}, flip rx : UInt<1>, overrun : UInt<1>}
    
    reg rateCounter : UInt<9>, clock with : (reset => (reset, UInt<9>("h00"))) @[uart.scala 44:30]
    reg bitCounter : UInt<3>, clock with : (reset => (reset, UInt<3>("h00"))) @[uart.scala 45:29]
    reg bits : UInt<1>[8], clock @[uart.scala 46:19]
    wire _rxRegs_WIRE : UInt<1>[4] @[uart.scala 47:33]
    _rxRegs_WIRE[0] <= UInt<1>("h00") @[uart.scala 47:33]
    _rxRegs_WIRE[1] <= UInt<1>("h00") @[uart.scala 47:33]
    _rxRegs_WIRE[2] <= UInt<1>("h00") @[uart.scala 47:33]
    _rxRegs_WIRE[3] <= UInt<1>("h00") @[uart.scala 47:33]
    reg rxRegs : UInt<1>[4], clock with : (reset => (reset, _rxRegs_WIRE)) @[uart.scala 47:25]
    reg overrun : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[uart.scala 48:26]
    reg running : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[uart.scala 49:26]
    reg outValid : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[uart.scala 51:27]
    reg outBits : UInt<8>, clock @[uart.scala 52:22]
    wire outReady : UInt<1>
    outReady <= io.out.ready
    io.out.valid <= outValid @[uart.scala 54:18]
    io.out.bits <= outBits @[uart.scala 55:17]
    node _T = and(outValid, outReady) @[uart.scala 57:19]
    when _T : @[uart.scala 57:32]
      outValid <= UInt<1>("h00") @[uart.scala 58:18]
      skip @[uart.scala 57:32]
    rxRegs[3] <= io.rx @[uart.scala 62:26]
    rxRegs[0] <= rxRegs[1] @[uart.scala 63:52]
    rxRegs[1] <= rxRegs[2] @[uart.scala 63:52]
    rxRegs[2] <= rxRegs[3] @[uart.scala 63:52]
    io.overrun <= overrun @[uart.scala 65:16]
    node _T_1 = eq(running, UInt<1>("h00")) @[uart.scala 67:10]
    when _T_1 : @[uart.scala 67:20]
      node _T_2 = eq(rxRegs[1], UInt<1>("h00")) @[uart.scala 68:14]
      node _T_3 = and(_T_2, rxRegs[0]) @[uart.scala 68:25]
      when _T_3 : @[uart.scala 68:39]
        rateCounter <= UInt<9>("h0137") @[uart.scala 69:25]
        bitCounter <= UInt<3>("h07") @[uart.scala 70:24]
        running <= UInt<1>("h01") @[uart.scala 71:21]
        skip @[uart.scala 68:39]
      skip @[uart.scala 67:20]
    else : @[uart.scala 73:18]
      node _T_4 = eq(rateCounter, UInt<1>("h00")) @[uart.scala 74:26]
      when _T_4 : @[uart.scala 74:35]
        bits[7] <= rxRegs[0] @[uart.scala 75:34]
        bits[0] <= bits[1] @[uart.scala 76:58]
        bits[1] <= bits[2] @[uart.scala 76:58]
        bits[2] <= bits[3] @[uart.scala 76:58]
        bits[3] <= bits[4] @[uart.scala 76:58]
        bits[4] <= bits[5] @[uart.scala 76:58]
        bits[5] <= bits[6] @[uart.scala 76:58]
        bits[6] <= bits[7] @[uart.scala 76:58]
        node _T_5 = eq(bitCounter, UInt<1>("h00")) @[uart.scala 77:29]
        when _T_5 : @[uart.scala 77:38]
          outValid <= UInt<1>("h01") @[uart.scala 78:26]
          node outBits_lo_hi = cat(bits[3], bits[2]) @[Cat.scala 30:58]
          node outBits_lo = cat(outBits_lo_hi, bits[1]) @[Cat.scala 30:58]
          node outBits_hi_lo = cat(bits[5], bits[4]) @[Cat.scala 30:58]
          node outBits_hi_hi = cat(bits[7], bits[6]) @[Cat.scala 30:58]
          node outBits_hi = cat(outBits_hi_hi, outBits_hi_lo) @[Cat.scala 30:58]
          node outBits_lo_1 = cat(outBits_hi, outBits_lo) @[Cat.scala 30:58]
          node _outBits_T = cat(rxRegs[0], outBits_lo_1) @[Cat.scala 30:58]
          outBits <= _outBits_T @[uart.scala 79:25]
          overrun <= outValid @[uart.scala 80:25]
          running <= UInt<1>("h00") @[uart.scala 81:25]
          skip @[uart.scala 77:38]
        else : @[uart.scala 82:26]
          rateCounter <= UInt<8>("h0cf") @[uart.scala 83:29]
          node _bitCounter_T = sub(bitCounter, UInt<1>("h01")) @[uart.scala 84:42]
          node _bitCounter_T_1 = tail(_bitCounter_T, 1) @[uart.scala 84:42]
          bitCounter <= _bitCounter_T_1 @[uart.scala 84:28]
          skip @[uart.scala 82:26]
        skip @[uart.scala 74:35]
      else : @[uart.scala 86:22]
        node _rateCounter_T = sub(rateCounter, UInt<1>("h01")) @[uart.scala 87:40]
        node _rateCounter_T_1 = tail(_rateCounter_T, 1) @[uart.scala 87:40]
        rateCounter <= _rateCounter_T_1 @[uart.scala 87:25]
        skip @[uart.scala 86:22]
      skip @[uart.scala 73:18]
    
  module UartTx : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<8>}, tx : UInt<1>}
    
    reg rateCounter : UInt<8>, clock with : (reset => (reset, UInt<8>("h00"))) @[uart.scala 12:30]
    reg bitCounter : UInt<4>, clock with : (reset => (reset, UInt<4>("h00"))) @[uart.scala 13:29]
    reg bits : UInt<1>[10], clock @[uart.scala 14:19]
    node _io_tx_T = eq(bitCounter, UInt<1>("h00")) @[uart.scala 16:25]
    node _io_tx_T_1 = or(_io_tx_T, bits[0]) @[uart.scala 16:33]
    io.tx <= _io_tx_T_1 @[uart.scala 16:11]
    node _io_in_ready_T = eq(bitCounter, UInt<1>("h00")) @[uart.scala 17:31]
    io.in.ready <= _io_in_ready_T @[uart.scala 17:17]
    node _T = and(io.in.valid, io.in.ready) @[uart.scala 19:22]
    when _T : @[uart.scala 19:38]
      node hi = cat(UInt<1>("h01"), io.in.bits) @[Cat.scala 30:58]
      node _T_1 = cat(hi, UInt<1>("h00")) @[Cat.scala 30:58]
      node _T_2 = bits(_T_1, 0, 0) @[uart.scala 20:43]
      node _T_3 = bits(_T_1, 1, 1) @[uart.scala 20:43]
      node _T_4 = bits(_T_1, 2, 2) @[uart.scala 20:43]
      node _T_5 = bits(_T_1, 3, 3) @[uart.scala 20:43]
      node _T_6 = bits(_T_1, 4, 4) @[uart.scala 20:43]
      node _T_7 = bits(_T_1, 5, 5) @[uart.scala 20:43]
      node _T_8 = bits(_T_1, 6, 6) @[uart.scala 20:43]
      node _T_9 = bits(_T_1, 7, 7) @[uart.scala 20:43]
      node _T_10 = bits(_T_1, 8, 8) @[uart.scala 20:43]
      node _T_11 = bits(_T_1, 9, 9) @[uart.scala 20:43]
      bits[0] <= _T_2 @[uart.scala 20:14]
      bits[1] <= _T_3 @[uart.scala 20:14]
      bits[2] <= _T_4 @[uart.scala 20:14]
      bits[3] <= _T_5 @[uart.scala 20:14]
      bits[4] <= _T_6 @[uart.scala 20:14]
      bits[5] <= _T_7 @[uart.scala 20:14]
      bits[6] <= _T_8 @[uart.scala 20:14]
      bits[7] <= _T_9 @[uart.scala 20:14]
      bits[8] <= _T_10 @[uart.scala 20:14]
      bits[9] <= _T_11 @[uart.scala 20:14]
      bitCounter <= UInt<4>("h0a") @[uart.scala 21:20]
      rateCounter <= UInt<8>("h0cf") @[uart.scala 22:21]
      skip @[uart.scala 19:38]
    node _T_12 = gt(bitCounter, UInt<1>("h00")) @[uart.scala 25:22]
    when _T_12 : @[uart.scala 25:30]
      node _T_13 = eq(rateCounter, UInt<1>("h00")) @[uart.scala 26:26]
      when _T_13 : @[uart.scala 26:35]
        bits[0] <= bits[1] @[uart.scala 28:54]
        bits[1] <= bits[2] @[uart.scala 28:54]
        bits[2] <= bits[3] @[uart.scala 28:54]
        bits[3] <= bits[4] @[uart.scala 28:54]
        bits[4] <= bits[5] @[uart.scala 28:54]
        bits[5] <= bits[6] @[uart.scala 28:54]
        bits[6] <= bits[7] @[uart.scala 28:54]
        bits[7] <= bits[8] @[uart.scala 28:54]
        bits[8] <= bits[9] @[uart.scala 28:54]
        node _bitCounter_T = sub(bitCounter, UInt<1>("h01")) @[uart.scala 29:38]
        node _bitCounter_T_1 = tail(_bitCounter_T, 1) @[uart.scala 29:38]
        bitCounter <= _bitCounter_T_1 @[uart.scala 29:24]
        rateCounter <= UInt<8>("h0cf") @[uart.scala 30:25]
        skip @[uart.scala 26:35]
      else : @[uart.scala 31:22]
        node _rateCounter_T = sub(rateCounter, UInt<1>("h01")) @[uart.scala 32:40]
        node _rateCounter_T_1 = tail(_rateCounter_T, 1) @[uart.scala 32:40]
        rateCounter <= _rateCounter_T_1 @[uart.scala 32:25]
        skip @[uart.scala 31:22]
      skip @[uart.scala 25:30]
    
  module UartSystem : 
    input clock : Clock
    input resetn : UInt<1>
    output tx : UInt<1>
    input rx : UInt<1>
    
    node _T = eq(resetn, UInt<1>("h00")) @[sample_uart.scala 15:28]
    inst uartRx of UartRx @[sample_uart.scala 18:24]
    uartRx.clock <= clock
    uartRx.reset <= _T
    inst uartTx of UartTx @[sample_uart.scala 19:24]
    uartTx.clock <= clock
    uartTx.reset <= _T
    uartTx.io.in.bits <= uartRx.io.out.bits @[sample_uart.scala 21:19]
    uartTx.io.in.valid <= uartRx.io.out.valid @[sample_uart.scala 21:19]
    uartRx.io.out.ready <= uartTx.io.in.ready @[sample_uart.scala 21:19]
    tx <= uartTx.io.tx @[sample_uart.scala 23:8]
    uartRx.io.rx <= rx @[sample_uart.scala 24:8]
    
